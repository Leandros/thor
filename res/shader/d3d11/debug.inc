/*
 * Smaller Number Printing - @P_Malin
 * Creative Commons CC0 1.0 Universal (CC-0)
 *
 * Feel free to modify, distribute or use in commercial code, just don't hold me liable for anything bad that happens!
 * If you use this code and want to give credit, that would be nice but you don't have to.
 *
 * I first made this number printing code in https://www.shadertoy.com/view/4sf3RN
 * It started as a silly way of representing digits with rectangles.
 * As people started actually using this in a number of places I thought I would try to condense the
 * useful function a little so that it can be dropped into other shaders more easily,
 * just snip between the perforations below.
 * Also, the licence on the previous shader was a bit restrictive for utility code.
 *
 * Disclaimer: The values printed may not be accurate!
 * Accuracy improvement for fractional values taken from TimoKinnunen https://www.shadertoy.com/view/lt3GRj
 *
 * ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----
 * Creative Commons CC0 1.0 Universal (CC-0)
 * https://www.shadertoy.com/view/4sBSWW
 *
 * ===========================================================================
 * Nov 8 2016: Converted to HLSL by yours truly!
 */

float
DigitBin(const int x)
{
    return x == 0 ? 480599.0
         : x == 1 ? 139810.0
         : x == 2 ? 476951.0
         : x == 3 ? 476999.0
         : x == 4 ? 350020.0
         : x == 5 ? 464711.0
         : x == 6 ? 464727.0
         : x == 7 ? 476228.0
         : x == 8 ? 481111.0
         : x == 9 ? 481095.0
         : 0.0;
}

float
PrintValue(
    const float2 vStringCoords,
    const float fValue,
    const float fMaxDigits,
    const float fDecimalPlaces)
{
    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;
	float fLog10Value = log2(abs(fValue)) / log2(10.0);
	float fBiggestIndex = max(floor(fLog10Value), 0.0);
	float fDigitIndex = fMaxDigits - floor(vStringCoords.x);
	float fCharBin = 0.0;
	if (fDigitIndex > (-fDecimalPlaces - 1.01)) {
		if (fDigitIndex > fBiggestIndex) {
			if ((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5)))
			    fCharBin = 1792.0;
		} else {
			if (fDigitIndex == -1.0) {
				if (fDecimalPlaces > 0.0)
				    fCharBin = 2.0;
			} else {
                float fReducedRangeValue = fValue;
                if (fDigitIndex < 0.0)
                    fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0;
				float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));
                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));
			}
        }
	}

    return floor(
        mod((fCharBin / pow(2.0, floor(
                        fract(vStringCoords.x) * 4.0)
                     + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));
}

/* ========================================================================= */
/* Original interface: */
float
PrintValue(
    const in float2 fragCoord,
    const in float2 vPixelCoords,
    const in float2 vFontSize,
    const in float fValue,
    const in float fMaxDigits,
    const in float fDecimalPlaces)
{
    float2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;
    return PrintValue(vStringCharCoords, fValue, fMaxDigits, fDecimalPlaces);
}

/* ---- 8< -------- 8< -------- 8< -------- 8< ---- */

